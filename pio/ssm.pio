; Configuration:
;
; Each output state machine can read from/write to up to 32 GPIO pins at once,
; using the in and out programs. These pins must be consecutive.
;
; Input program
;
; Between iterations:
; - X holds previous GPIO value
; - Y holds counter (decremented every 6 instructions)
; - OSR is used to back up Y between cmp and update
;
; This program is pipelined to increase the frequency at which the counter is
; updated (which also determines the granularity of timestamping).
;
; There are two phases of the pipeline. The cmp phase polls the GPIO pins,
; and loops every 6 instructions when there are no changes on the GPIO pins.
; Thus, the cmp phase decrements the counter once every iteration.
;
; The update phase is triggered when changes are found on the GPIO pins, which
; writes the GPIO input and then the current counter to the FIFO. It takes 12
; instructions to go through the cmp then update phase, so it decrements the
; counter twice before returning to cmp.
;
; Because jmp y--, <DEST> will fall throuh when y is zero, we add an additional
; "spillover" block for the cmp phase which does the exact same thing as cmp
; (we can't naively jump back because the instructions will be out of phase).
;
; Due to the fact that the update phase takes twice as long as the cmp phase,
; if the GPIO input rapidly changes twice, the second change will be delayed
; by 6 instructions worth of time.
;
; FIFO protocol: (gpio_in ; input_time)
;                --------- time ------->
;
; TODO: determine IRQ number (and set it up??)
;
; NOTE: The SDK documentation (3.5.6.3) notes that GPIO pins are equipped with
; a 2-flipflop synchronizer, which adds 2 cycles of latency. This is less than
; the 6-cycle clock period of this input program.

.define public SSM_INPUT_IRQ_NUM 0

.program ssm_input
    in pins, 32         ; ISR <- read GPIO
    mov x, isr          ; X <- ISR
    set y, 0            ; Y <- 0
.wrap_target
cmp:
    mov osr, y          ; OSR <- Y (back up counter)
    in pins, 32         ; ISR <- read GPIO
    mov y, isr          ; Y <- ISR
    jmp x!=y, update    ; Compare prev with cur
    mov y, osr          ; Y <- OSR (restore counter)
resume_cmp:
    jmp y--, cmp        ; Y--, return to cmp
; cmp spillover block, in case Y was zero
    mov osr, y          ; OSR <- Y (back up counter)
    in pins, 32         ; ISR <- read GPIO
    mov y, isr          ; Y <- ISR
    jmp x!=y, update    ; Compare prev with cur
    mov y, osr          ; Y <- OSR (restore counter)
    jmp y--, cmp        ; Y--, resume cmp
; We don't need to worry about spillover here since Y-- can never be zero twice
update:
    mov x, isr          ; X <- ISR (set prev to cur)
    push noblock        ; FIFO <- ISR
    mov isr, osr        ; ISR <- OSR (currently storing counter)
    push noblock        ; FIFO <- ISR
    irq nowait SSM_INPUT_IRQ_NUM ; notify CPU
    mov y, osr          ; Y <- OSR (restore counter)
    jmp y--, resume_cmp ; Y--, goto Y-- in cmp phase so Y is decremented again
    jmp y--, cmp        ; Y--, always loops back to cmp
.wrap

% c-sdk {
/*! \brief Setup SSM input program, and enable the state machine.
 *
 * This function handles all PIO configuration for the caller, including:
 * - load the program into the specified PIO instance
 * - claim a state machine from the specified PIO instance
 * - configure GPIO pins for input
 * - set clock rate (TODO)
 * - configure interrupt handler (TODO)
 *
 * For some reason, the PIO API does not allow setting the pin count, only the
 * pin base. So for now, we require that pin_count be set to 32.
 *
 * \param pio           The PIO instance; either \ref pio0 or \ref pio1
 * \param pin_base      The first input pin to use for SSM input
 * \param pin_count     The number of consecutive pins use as SSM input
 * \return              State machine where program is installed; negative if error
 */
static inline int ssm_input_program_start(PIO pio, uint pin_base, uint pin_count) {
    if (pin_count != 32)
        // Only support 32 input pins at once
        return -1;

    if (!pio_can_add_program(pio, &ssm_input_program))
        // Can't add program
        return -1;

    uint offset = pio_add_program(pio, &ssm_input_program);

    int sm = pio_claim_unused_sm(pio, false);
    if (sm < 0)
        // No state machines available at pio
        return -1;

    pio_sm_config c = ssm_input_program_get_default_config(offset);

    // Set GPIO input pins according to parameters
    sm_config_set_in_pins(&c, pin_base);

    // Note that pio_gpio_init() is apparently not needed for reading GPIO input
    // but the examples do this so we shall do this too
    for (int i = 0; i < pin_count; i++)
        pio_gpio_init(pio, pin_base + i);

    // On our state machine, set the pins' direction to input
    pio_sm_set_consecutive_pindirs(pio, sm, pin_base, pin_count, false);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);

    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);

    return sm;
}
%}

; Output program
;
; Between loops:
; - X holds the counter (decremented every 4 instructions)
; - Y holds the target time
;
; This program consists of two loops: the poll loop and the hold loop. Each loop
; always consists of exactly four instructions, and decrements X exactly once
; each loop iteration.
;
; The poll loop polls for packets from the user, containing the target time.
; If no packet is present, pull noblock will load OSR with the contents of
; register X (holding the counter), so if X and OSR are equal, then no packet is
; received. The target time MUST be less than 2^32-1 away from the current
; counter value in order to be considered (but then again this is necessary
; anyway to account for wraparound).
;
; The hold loop waits for the counter to reach the target time. There are
; a bunch of nops to ensure that the counter is always decremented at the same
; rate. When the target time is reached, the GPIO output is read from the FIFO
; and written to the pins.
;
; FIFO protocol: (target_time ; gpio_out)
;                ---------- time -------->
;
; NOTE: the CPU MUST:
;   - write target times in decreasing (chronologically increasing) order
;   - write target_time less than 2^32-1 away from the current counter
;   - write target_time more than 2 away from the current counter
;   - write target_time more than 2 away from the previous target_time
;   - always write two consecutive packets, target_time and gpio_out
;   - write the gpio_out the FIFO before target_time expires
;
; TODO: consider this:
;
; If the CPU cannot guarantee to write gpio_out before target_time expires,
; there is an alternate implementation that leverages another separate state
; machine to specifically handle GPIO outputs. This also has the following
; advantages and disadvantages:
;
;   - doubles the effective size of the FIFO
;   - guarantees not to reinterpret target time as GPIO output, so output won't
;     be totally corrupted due to unexpected CPU stalling
;   - halves the number of state machines available (if we care about this)
;
; It's not that much more complicated; this ssm_output program can be easily
; adapted to support that.
;
.program ssm_output
    set x, 0                ; X <- 0
.wrap_target
poll:
    pull noblock            ; OSR <- FIFO else X
    mov y, osr              ; Y <- OSR  (load for comparison)
    jmp x!=y, hold_new      ; X != Y    (new packet received)
    jmp x--, poll           ; X--       (no packet received)
    pull noblock            ; spillover (no jump when X is zero)
    mov y, osr              ; Y <- OSR  (load for comparison)
    jmp x!=y, hold_new      ; X != Y    (new packet received)
    jmp x--, poll           ; X--       (no packet received)
hold_stall:
    nop                     ; Need to stall 3 more cycles before next hold loop
    nop                     ; iteration to align 4-instruction cycle
hold_new:
    jmp x--, hold           ; X--, enter hold loop
hold:
    jmp x!=y, hold_stall    ; X != Y (target time not reached)
    pull noblock            ; OSR <- FIFO else X (which would be garbage)
    out pins, 32            ; Write output to GPIO pins
    jmp x--, poll           ; X--, return to poll loop
.wrap

% c-sdk {
static inline int ssm_output_program_start(PIO pio, uint pin_base, uint pin_count) {
    if (!pio_can_add_program(pio, &ssm_input_program))
        // Can't add program
        return -1;

    uint offset = pio_add_program(pio, &ssm_input_program);

    int sm = pio_claim_unused_sm(pio, false);
    if (sm < 0)
        // No state machines available at pio
        return -1;

    pio_sm_config c = ssm_output_program_get_default_config(offset);

    // Set GPIO output pins according to parameters
    sm_config_set_out_pins(&c, pin_base, pin_count);

    // Connect GPIO pins to PIO for output
    for (int i = 0; i < pin_count; i++)
        pio_gpio_init(pio, pin_base + i);

    // On our state machine, set the pins' direction to output
    pio_sm_set_consecutive_pindirs(pio, sm, pin_base, pin_count, true);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);

    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);

    return sm;
}
%}
