.define PUBLIC CPU_TO_MYPIO_IRQ 5
.program ssm_input
set x, 0
write:
mov y, x
mov isr, x
push
.wrap_target
in pins, 1
in null, 31
mov x, isr
jmp x!=y write
.wrap

% c-sdk {
// With a clock divider of 4096, these state machines should execute at a rate
// of 1 instruction per (4096 / 125MHz) = 32.768us.
/* #define MYCLKDIV 4096 */
#define MYCLKDIV 256

// With a clock divider of 8192, these state machines should execute at a rate
// of 1 instruction per (8192 / 125MHz) = 65.536us.
/* #define MYCLKDIV 8192 */
static inline void ssm_input_init(PIO pio, uint pin_in, uint pin_out) {

    uint offset = pio_add_program(pio, &ssm_input_program);
    int sm = pio_claim_unused_sm(pio, false);
    pio_sm_config c = ssm_input_program_get_default_config(offset);

    sm_config_set_clkdiv_int_frac(&c, MYCLKDIV, 0);

    sm_config_set_in_pins(&c, pin_in);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_in, 1, false);
    sm_config_set_set_pins(&c, pin_out, 1);
    sm_config_set_out_pins(&c, pin_out, 1);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_out, 1, true);

    pio_gpio_init(pio, pin_in);
    pio_gpio_init(pio, pin_out);

    pio_sm_init(pio, sm, offset, &c);

    pio_set_sm_mask_enabled(pio, 1 << sm, true);
}
%}
